<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Unit testing with Design By Contract (part 2)</title>
  <meta name="description" content="Unit testing with Design By Contract (part 2) This article is the second of three on Unit Testing and Design By Contract Testing Post Conditions and Class Invariants Our User Story contains two pre conditions, so we should write a test for each of them. [Test, ExpectedException( typeof(ArgumentNullException))] public void Add_PreCond_ItemIsRequired() { new Stack(maximumNumberOfItemsAllowed: 1) .Add(null); } [Test, ExpectedException(typeof(InvalidOperationException), ExpectedMessage=&quot;Cannot add items when the stack is full.&quot;)] public void Add_PreCond_StackCantBeFull() { new Stack(maximumNumberOfItemsAllowed: 0) .Add(new object()); } These unit tests ensure that if any of the two pre conditions are not satisfied, the Supplier will not execute the method. To do so, it throws an error to the Client. When we unit tests this behaviour, we assert that the Unit Tests will result in an exception being thrown, and we can additionally specify the type of the exception. These types of tests are also known as Unhappy Tests. Happy Case: The N + 1 Pre Condition How do you test that all pre conditions are met? Well, you could argue that is not needed, when testing post conditions we can assume that the method is executed, what means that we passed all pre condition checks. Let’s suppose a new pre condition is added to the class, and that the developer forgets to write the Unit Test for it. Yes, all post-condition tests should now fail: there is a new pre condition in town. But this may not happen, what if the new pre condition was coincidentally met by all tests? For example, a new requirement that only allows us to add non empty strings to the stack may not be detected by any existing test if they already use non empty strings only. There is another problem, related to error localization. In his brilliant book “Working Effectively with Legacy Code” Michael Feathers emphasizes that one of the benefits of good tests is that it helps us to easily localize problems. With a happy case, we do not want to test the outcome of a method. We want to check that if all pre requisites are satisfied, the method throws no error. This is the opposite scenario of an unhappy case, that is, a happy case for pre conditions. [Test] public void Add_PreCond_HappyCase() { new Stack(maximumNumberOfItemsAllowed: 1) .Add(new object()); } Notice that we are not doing any checking on this test. We simply want to pass all the validations for pre conditions. We are also not interested in testing the state of the stack after adding the item. In other words, we are not testing pre conditions either. We will do that in the nexdt part Coming Next: Testing Post Conditions and Class Invariants">
  

  <link rel="stylesheet" href="/blog/assets/main.css">
  <link rel="canonical" href="http://youarewhatyoucode/blog/2011/08/12/unit-test-design-by-contract-part2/">
  
  
  <link rel="alternate" type="application/rss+xml" title="you are what you code" href="http://youarewhatyoucode/blog/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Unit testing with Design By Contract (part 2)">
  <meta name="twitter:description" content="Unit testing with Design By Contract (part 2) This article is the second of three on Unit Testing and Design By Contract Testing Post Conditions and Class Invariants Our User Story contains two pre...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">you are what you code</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="https://ie.linkedin.com/in/sebastianslutzky">About</a>
      
        
        <a class="page-link" href="/blog/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/sebastianslutzky">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Unit testing with Design By Contract (part 2)</h1>
    
    <p class="post-meta"><time datetime="2011-08-12T00:00:00+00:00" itemprop="datePublished">Aug 12, 2011</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1>Unit testing with Design By Contract (part 2)</h1>
<div id="preamble">
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="/images/dbc.png" alt="dbc" width="100%">
</div>
</div>
<div class="paragraph">
<p><em>This article is the second of three on <a href="http://sebastianslutzky.com/2011/08/08/unit-testing-with-design-by-contract/">Unit Testing and Design By Contract</a></em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing_post_conditions_and_class_invariants">Testing Post Conditions and Class Invariants</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our User Story contains two pre conditions, so we should write a test for each of them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="csharp">[Test, ExpectedException( typeof(ArgumentNullException))]
public void Add_PreCond_ItemIsRequired()
{
    new Stack(maximumNumberOfItemsAllowed: 1)
        .Add(null);
}

[Test,
ExpectedException(typeof(InvalidOperationException),
    ExpectedMessage="Cannot add items when the stack is full.")]
public void Add_PreCond_StackCantBeFull()
{
    new Stack(maximumNumberOfItemsAllowed: 0)
        .Add(new object());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These unit tests ensure that if any of the two pre conditions are not satisfied, the Supplier will not execute the method. To do so, it throws an error to the Client.</p>
</div>
<div class="paragraph">
<p>When we unit tests this behaviour, we assert that the Unit Tests will result in an exception being thrown, and we can additionally specify the type of the exception. These types of tests are also known as Unhappy Tests.</p>
</div>
<div class="sect2">
<h3 id="happy_case_the_n_1_pre_condition">Happy Case: The N + 1 Pre Condition</h3>
<div class="paragraph">
<p>How do you test that all pre conditions are met? Well, you could argue that is not needed, when testing post conditions we can assume that the method is executed, what means that we passed all pre condition checks.</p>
</div>
<div class="paragraph">
<p>Let’s suppose a new pre condition is added to the class, and that the developer forgets to write the Unit Test for it. Yes, all post-condition tests should now fail: there is a new pre condition in town. But this may not happen, what if the new pre condition was coincidentally met by all tests? For example, a new requirement that only allows us to add non empty strings to the stack may not be detected by any existing test if they already use non empty strings only.</p>
</div>
<div class="paragraph">
<p>There is another problem, related to error localization. In his brilliant book “Working Effectively with Legacy Code” Michael Feathers emphasizes that one of the benefits of good tests is that it helps us to easily localize problems. With a happy case, we do not want to test the outcome of a method. We want to check that if all pre requisites are satisfied, the method throws no error. This is the opposite scenario
of an unhappy case, that is, a happy case for pre conditions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="csharp">[Test]
public void Add_PreCond_HappyCase()
{
    new Stack(maximumNumberOfItemsAllowed: 1)
        .Add(new object());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that we are not doing any checking on this test. We simply want to pass all the validations for pre conditions. We are also not interested in testing the state of the stack after adding the item. In other words, we are not testing pre conditions either. We will do that in the nexdt part</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coming_next">Coming Next:</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://sebastianslutzky.wordpress.com/2011/08/13/testing-post-conditions-and-class-invariants/">Testing Post Conditions and Class Invariants</a></p>
</div>
</div>
</div>
  </div>

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; sebastian slutzky - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="http://youarewhatyoucode/blog/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
