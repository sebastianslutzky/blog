<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Unit Test &amp; Design By Contract (Part I)</title>
  <meta name="description" content="One of the most useful metaphors for organising software is the one of Design by Contract. This technique, which was formalised by Bertrand Meyer in 1986 has its roots in previous ideas from Tony Hoare and Barbara Liskov. In a nutshell, DBC equates the relationship of two pieces of software (i.e. two methods) to that of a Client and a Supplier in the business world, both interacting with each other with clear rights and obligations, specified in a Contract. In DBC, a Supplier can serve a request from a Client only if the latter satisfy the prerequisites or preconditions required by the Supplier. The Supplier has an obligation to return a property as expected by the Client, the post-condition, once the request is served. Additionally, a contract must specify certain properties that must remain true before and after the nteraction between Client and Supplier. This obligation is known as a class invariant. Example: A classic example to show DBC in practice is by building a data structure class, such as a Stack class. The rules of adding items to this structure are very clear: Pre conditions An item must be provided to be added to the stack There must be room in the stack to store the item Post conditions The number of items in the Stack increased by one The item on top of the Stack is the one we just added Class Invariants The  number of items in the Stack  are greater or equal than zero The number of items in the Stack are less or equal to the maximum size allowed Who checks the contract? Typically, a method checks the pre-conditions of the contract only. If any of the pre conditions were not enforced by the Client of the method, the Supplier will not continue with the execution of the method since its result (and even its execution) can be unexpected. This is usually done by assertions at the beginning of a method: we assert that a precondition is true prior to executing the method, if the assertion is wrong, then the execution is suspended (an exception is thrown). Post conditions and Class Invariant could, in theory, be checked in code too. However, this would lead to very long, unreadable and inefficient code. Also, in many cases testing the post-conditions is simply not viable. Remember the DBC metaphor and it will be clear that the party who is responsible for an obligation (the Supplier in this case) cannot be in charge of verifying that the obligation has been fulfilled (i.e. that the post condition is true). Now, the Client could verify Post-Conditions and Class invariants, but we don’t know (and shouldn’t care) who will be the client of the method we are currently building. And if we are creating a Client of a method, our code requires the Supplier to do what is expected when we invoke its method. So where do we test Post conditions and Class invariants? You know the answer, in the Unit Tests. Each of the six rules defined above can be converted into a unit test. This is what we’ll do next. A structure for your tests But before writing the tests, let me suggest a naming convention for them. I like naming the tests using the following pattern: %MethodName%%ruleType%%Description% Where rule type is any of the three types of DBC rule: pre condition, post condition or class invariant Here is the list of test we will write for this User Story, based on the previous pattern [Test] public void Add_PreCond_ItemIsRequired() { throw new NotImplementedException(); } [Test] public void Add_PreCond_StackCantBeFull() { throw new NotImplementedException(); } [Test] public void Add_PreCond_HappyCase() { throw new NotImplementedException(); } [Test] public void Add_PostCond_CountHasIncreasedByOne() { throw new NotImplementedException(); } [Test] public void Add_PostCond_ItemIsOnTopOfTheStack() { throw new NotImplementedException(); } [Test] public void Add_PostCond_InvariantsWereEnforced() { throw new NotImplementedException(); } [Test] public void CheckInvariants_PostCond_CountIsNonNegative() { throw new NotImplementedException(); } [Test] public void CheckInvariants_PostCond_CountIsLessThanMaximumAllowed() { throw new NotImplementedException(); } The Happy Case test was not in the list, and there are two tests for a method called Check Invariants. We will look into these tests in detail later. Typically you would put these methods in a class called StackTests. However, if you have a method that requires a large number of tests, you can have one test class per method instead. Your test class would be named Stack_AddTests and the test names would be, for example, PreCond_ItemIsRequired. Generating Documentation from your Tests By following this structure for tests and fixtures, we can enrich the documentation generated from our code. This requires customisation of tools like NDoc or Sandcastle. The exact implementation is outside of the scope of this article, but I will post it at some point. The idea is to parse the name of Fixtures and Tests to append pre and post conditions to their relative methods, in a readable way. One caveat I have with this idea is that you have to remember that you are not using the “true” code for generating the docs, but the names of the apis. This means that your documentation will be as accurate as the name of your tests. Coming next: Checking Pre Conditions">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://youarewhatyoucode/2011/08/08/unit-test-design-by-contract-part1/">
  
  
  <link rel="alternate" type="application/rss+xml" title="you are what you code" href="http://youarewhatyoucode/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Unit Test &amp; Design By Contract (Part I)">
  <meta name="twitter:description" content="One of the most useful metaphors for organising software is the one of Design by Contract. This technique, which was formalised by Bertrand Meyer in 1986 has its roots in previous ideas from Tony H...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">you are what you code</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="https://ie.linkedin.com/in/sebastianslutzky">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/sebastianslutzky">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Unit Test &amp; Design By Contract (Part I)</h1>
    
    <p class="post-meta"><time datetime="2011-08-08T00:00:00+00:00" itemprop="datePublished">Aug 8, 2011</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div class="imageblock">
<div class="content">
<img src="/assets/images/dbc.png" alt="dbc" width="100%">
</div>
</div>
<div class="paragraph">
<p>One of the most useful metaphors for organising software is the one of Design by Contract.</p>
</div>
<div class="paragraph">
<p>This technique, which was formalised by Bertrand Meyer in 1986 has its roots in previous ideas from Tony Hoare and Barbara Liskov.
In a nutshell, DBC equates the relationship of two pieces of software (i.e. two methods) to that of a <strong><em>Client</em></strong> and a <strong><em>Supplier</em></strong> in the business world,
both interacting with each other with clear rights and obligations, specified in a <strong><em>Contract</em></strong>.</p>
</div>
<div class="paragraph">
<p>In DBC, a <em>Supplier</em> can serve a request from a <em>Client</em> only if the latter satisfy the prerequisites or <strong><em>preconditions</em></strong> required by the <em>Supplier</em>.
The <em>Supplier</em> has an obligation to return a property as expected by the <em>Client</em>, the <strong><em>post-condition</em></strong>, once the request is served.</p>
</div>
<div class="paragraph">
<p>Additionally, a contract must specify certain properties that must remain true before and after the nteraction between <em>Client</em> and <em>Supplier</em>.
This obligation is known as a <strong><em>class invariant</em></strong>.</p>
</div>
<div class="sect2">
<h3 id="example">Example:</h3>
<div class="paragraph">
<p>A classic example to show DBC in practice is by building a data structure class, such as a Stack class. The rules of adding items to this structure are very clear:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pre conditions</strong></p>
<div class="ulist">
<ul>
<li>
<p>An item must be provided to be added to the stack</p>
</li>
<li>
<p>There must be room in the stack to store the item</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Post conditions</strong></p>
<div class="ulist">
<ul>
<li>
<p>The number of items in the Stack increased by one</p>
</li>
<li>
<p>The item on top of the Stack is the one we just added</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Class Invariants</strong></p>
<div class="ulist">
<ul>
<li>
<p>The  number of items in the Stack  are greater or equal than zero</p>
</li>
<li>
<p>The number of items in the Stack are less or equal to the maximum size allowed</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="who_checks_the_contract">Who checks the contract?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Typically, a method checks the pre-conditions of the contract only. If any of the pre conditions were not enforced by the Client of the method, the Supplier will not continue with the execution of the method since its result (and even its execution) can be unexpected. This is usually done by assertions at the beginning of a method: we assert that a precondition is true prior to executing the method, if the assertion is wrong, then the execution is suspended (an exception is thrown).</p>
</div>
<div class="paragraph">
<p>Post conditions and Class Invariant could, in theory, be checked in code too. However, this would lead to very long, unreadable and inefficient code. Also, in many cases testing the post-conditions is simply not viable. Remember the DBC metaphor and it will be clear that the party who is responsible for an obligation (the Supplier in this case) cannot be in charge of verifying that the obligation has been fulfilled (i.e. that the post condition is true).</p>
</div>
<div class="paragraph">
<p>Now, the Client could verify Post-Conditions and Class invariants, but we don’t know (and shouldn’t care) who will be the client of the method we are currently building. And if we are creating a Client of a method, our code requires the Supplier to do what is expected when we invoke its method. So where do we test Post conditions and Class invariants? You know the answer, in the Unit Tests.</p>
</div>
<div class="paragraph">
<p>Each of the six rules defined above can be converted into a unit test. This is what we’ll do next.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a_structure_for_your_tests">A structure for your tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>But before writing the tests, let me suggest a naming convention for them. I like naming the tests using the following pattern:
%MethodName%<em>%ruleType%</em>%Description%</p>
</div>
<div class="paragraph">
<p>Where rule type is any of the three types of DBC rule: pre condition, post condition or class invariant
Here is the list of test we will write for this User Story, based on the previous pattern</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="csharp"><span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PreCond_ItemIsRequired</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PreCond_StackCantBeFull</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PreCond_HappyCase</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PostCond_CountHasIncreasedByOne</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PostCond_ItemIsOnTopOfTheStack</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">Add_PostCond_InvariantsWereEnforced</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">CheckInvariants_PostCond_CountIsNonNegative</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }

<span style="color: #7D9029">[Test]</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">void</span> <span style="color: #0000FF">CheckInvariants_PostCond_CountIsLessThanMaximumAllowed</span>()
    { <span style="color: #008000; font-weight: bold">throw</span> <span style="color: #008000; font-weight: bold">new</span> NotImplementedException(); }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>Happy Case</em> test was not in the list, and there are two tests for a method called <code>Check Invariants</code>. We will look into these tests in detail later.
Typically you would put these methods in a class called <code>StackTests</code>. However, if you have a method that requires a large number of tests, you can have one test class per method instead.
Your test class would be named <code>Stack_AddTests</code> and the test names would be, for example, <code>PreCond_ItemIsRequired</code>.</p>
</div>
<div class="sect2">
<h3 id="generating_documentation_from_your_tests">Generating Documentation from your Tests</h3>
<div class="paragraph">
<p>By following this structure for tests and fixtures, we can enrich the documentation generated from our code.
This requires customisation of tools like <a href="http://ndoc.sourceforge.net">NDoc</a> or <a href="http://sandcastle.codeplex.com/">Sandcastle</a>.
The exact implementation is outside of the scope of this article, but I will post it at some point. The idea is to parse the name of Fixtures and Tests to append pre and post conditions to their relative methods, in a readable way.</p>
</div>
<div class="paragraph">
<p>One caveat I have with this idea is that you have to remember that you are not using the “true” code for generating the docs, but the names of the apis. This means that your documentation will be as accurate as the name of your tests.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coming_next">Coming next:</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="/2011/08/12/unit-test-design-by-contract-part2">Checking Pre Conditions</a></p>
</div>
</div>
</div>
  </div>

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; sebastian slutzky - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="http://youarewhatyoucode/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
